{"version":3,"file":"clientService-scOH6ADK.js","sources":["../../src/services/productService.ts","../../src/services/printerService.ts","../../src/hooks/useClients.ts","../../src/services/clientService.ts"],"sourcesContent":["import { supabase } from '@/integrations/supabase/client';\r\nimport { Product, ProductWithSuppliers, ProductSupplier, Supplier, PriceHistory, ProductWithClients, ProductClient, Client, ClientPriceHistory, Printer } from '@/types/database';\r\n\r\nexport interface CreateProductData {\r\n  name: string;\r\n  sku: string;\r\n  category: string;\r\n  description?: string;\r\n  color?: string;\r\n  alias?: string;\r\n}\r\n\r\nexport interface UpdateProductData {\r\n  name?: string;\r\n  sku?: string;\r\n  category?: string;\r\n  description?: string;\r\n  color?: string;\r\n  alias?: string;\r\n}\r\n\r\nclass ProductService {\r\n  async getProducts(): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n      .from('products')\r\n      .select('*')\r\n      .order('name');\r\n\r\n    if (error) {\r\n      console.error('Error fetching products:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data || [];\r\n  }\r\n\r\n  async getProductById(id: string): Promise<Product | null> {\r\n    const { data, error } = await supabase\r\n      .from('products')\r\n      .select('*')\r\n      .eq('id', id)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error fetching product:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  async getProductsByPrinter(printerId: string): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n      .from('product_printers')\r\n      .select(`\r\n        product:products(*)\r\n      `)\r\n      .eq('printer_id', printerId)\r\n      .order('product(name)', { ascending: true })\r\n      .order('product(color)', { ascending: true });\r\n\r\n    if (error) {\r\n      console.error('Error fetching products by printer:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data?.map(pp => pp.product).filter(Boolean) || [];\r\n  }\r\n\r\n  async getProductWithSuppliers(productId: string): Promise<ProductWithSuppliers | null> {\r\n    const { data: product, error: productError } = await supabase\r\n      .from('products')\r\n      .select('*')\r\n      .eq('id', productId)\r\n      .single();\r\n\r\n    if (productError) {\r\n      console.error('Error fetching product:', productError);\r\n      throw productError;\r\n    }\r\n\r\n    if (!product) return null;\r\n\r\n    const { data: suppliers, error: suppliersError } = await supabase\r\n      .from('product_suppliers')\r\n      .select(`\r\n        *,\r\n        supplier:suppliers(*),\r\n        priceHistory:price_history(*)\r\n      `)\r\n      .eq('product_id', productId);\r\n\r\n    if (suppliersError) {\r\n      console.error('Error fetching product suppliers:', suppliersError);\r\n      throw suppliersError;\r\n    }\r\n\r\n    const { data: printers, error: printersError } = await supabase\r\n      .from('product_printers')\r\n      .select(`\r\n        *,\r\n        printer:printers(*)\r\n      `)\r\n      .eq('product_id', productId);\r\n\r\n    if (printersError) {\r\n      console.error('Error fetching product printers:', printersError);\r\n      throw printersError;\r\n    }\r\n\r\n    return {\r\n      ...product,\r\n      suppliers: suppliers || [],\r\n      printers: ((printers || []) as any[]).map(pp => pp.printer).filter(Boolean) as Printer[]\r\n    };\r\n  }\r\n\r\n  async getProductWithClients(productId: string): Promise<ProductWithClients | null> {\r\n    const { data: product, error: productError } = await supabase\r\n      .from('products')\r\n      .select('*')\r\n      .eq('id', productId)\r\n      .single();\r\n\r\n    if (productError) {\r\n      console.error('Error fetching product:', productError);\r\n      throw productError;\r\n    }\r\n\r\n    if (!product) return null;\r\n\r\n    const { data: clients, error: clientsError } = await supabase\r\n      .from('product_clients')\r\n      .select(`\r\n        *,\r\n        client:clients(*),\r\n        priceHistory:client_price_history(*)\r\n      `)\r\n      .eq('product_id', productId);\r\n\r\n    if (clientsError) {\r\n      console.error('Error fetching product clients:', clientsError);\r\n      throw clientsError;\r\n    }\r\n\r\n    const { data: printers, error: printersError } = await supabase\r\n      .from('product_printers')\r\n      .select(`\r\n        *,\r\n        printer:printers(*)\r\n      `)\r\n      .eq('product_id', productId);\r\n\r\n    if (printersError) {\r\n      console.error('Error fetching product printers:', printersError);\r\n      throw printersError;\r\n    }\r\n\r\n    return {\r\n      ...product,\r\n      clients: clients || [],\r\n      printers: ((printers || []) as any[]).map(pp => pp.printer).filter(Boolean) as Printer[]\r\n    };\r\n  }\r\n\r\n  async createProduct(productData: CreateProductData): Promise<Product> {\r\n    const { data, error } = await supabase\r\n      .from('products')\r\n      .insert([productData])\r\n      .select()\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error creating product:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  async updateProduct(id: string, productData: UpdateProductData): Promise<Product> {\r\n    console.log('productService.updateProduct called with:', { id, productData });\r\n    \r\n    const { data, error } = await supabase\r\n      .from('products')\r\n      .update(productData)\r\n      .eq('id', id)\r\n      .select()\r\n      .single();\r\n\r\n    console.log('Supabase response:', { data, error });\r\n\r\n    if (error) {\r\n      console.error('Error updating product:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  async deleteProduct(id: string, replacementProductId?: string): Promise<void> {\r\n    // Check for transaction_records referencing this product\r\n    const { data: transactions, error: fetchError } = await supabase\r\n      .from('transaction_records')\r\n      .select('id')\r\n      .eq('product_id', id);\r\n    if (fetchError) {\r\n      console.error('Error checking related transaction records:', fetchError);\r\n      throw fetchError;\r\n    }\r\n    if (transactions && transactions.length > 0) {\r\n      if (!replacementProductId) {\r\n        throw new Error('Product is still referenced by transaction_records. Please reassign or provide a replacementProductId.');\r\n      }\r\n      // Reassign all transaction_records to the replacement product\r\n      const { error: updateError } = await supabase\r\n        .from('transaction_records')\r\n        .update({ product_id: replacementProductId })\r\n        .eq('product_id', id);\r\n      if (updateError) {\r\n        console.error('Error reassigning transaction records:', updateError);\r\n        throw updateError;\r\n      }\r\n    }\r\n    // Now delete the product\r\n    const { error } = await supabase\r\n      .from('products')\r\n      .delete()\r\n      .eq('id', id);\r\n    if (error) {\r\n      console.error('Error deleting product:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async mergeProducts(primaryProductId: string, otherProductIds: string[], newAlias: string): Promise<void> {\r\n    const primaryProduct = await this.getProductById(primaryProductId);\r\n    if (!primaryProduct) {\r\n        console.error('Could not fetch primary product');\r\n        throw new Error('Could not fetch primary product');\r\n    }\r\n\r\n    let mergedData: UpdateProductData = {\r\n        alias: newAlias,\r\n        color: primaryProduct.color,\r\n        description: primaryProduct.description\r\n    };\r\n    \r\n    for (const otherId of otherProductIds) {\r\n        const otherProduct = await this.getProductById(otherId);\r\n        if (!otherProduct) {\r\n            console.warn(`Could not fetch product ${otherId}, skipping.`);\r\n            continue;\r\n        }\r\n\r\n        if (!mergedData.color && otherProduct.color) {\r\n            mergedData.color = otherProduct.color;\r\n        }\r\n        if (!mergedData.description && otherProduct.description) {\r\n            mergedData.description = otherProduct.description;\r\n        }\r\n    }\r\n\r\n    await this.updateProduct(primaryProductId, mergedData);\r\n\r\n    for (const otherId of otherProductIds) {\r\n      const { error: transactionError } = await supabase\r\n        .from('transaction_records')\r\n        .update({ product_id: primaryProductId })\r\n        .eq('product_id', otherId);\r\n\r\n      if (transactionError) {\r\n        console.error(`Error re-assigning transaction records from ${otherId}:`, transactionError);\r\n      }\r\n      \r\n      const linkingTables = [\r\n        { name: 'product_printers', conflictColumn: 'printer_id' },\r\n        { name: 'product_suppliers', conflictColumn: 'supplier_id' },\r\n        { name: 'product_clients', conflictColumn: 'client_id' }\r\n      ];\r\n\r\n      for (const tableInfo of linkingTables) {\r\n        const { data: relatedItems, error: fetchError } = await supabase\r\n          .from(tableInfo.name as any)\r\n          .select('*')\r\n          .eq('product_id', otherId);\r\n        \r\n        if (fetchError) {\r\n          console.error(`Error fetching related items from ${tableInfo.name} for product ${otherId}:`, fetchError);\r\n          continue;\r\n        }\r\n\r\n        if (relatedItems && relatedItems.length > 0) {\r\n          const itemsToUpsert = relatedItems.map((item: any) => {\r\n            const { id, product_id, ...rest } = item;\r\n            return { ...rest, product_id: primaryProductId };\r\n          });\r\n          \r\n          const { error: upsertError } = await supabase\r\n            .from(tableInfo.name as any)\r\n            .upsert(itemsToUpsert, { onConflict: `product_id, ${tableInfo.conflictColumn}` });\r\n\r\n          if (upsertError) {\r\n            console.error(`Error upserting relations into ${tableInfo.name}:`, upsertError);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const { error: deleteError } = await supabase\r\n      .from('products')\r\n      .delete()\r\n      .in('id', otherProductIds);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting merged products:', deleteError);\r\n      throw deleteError;\r\n    }\r\n  }\r\n\r\n  // Fixed addSupplierToProduct to properly handle both existing and new suppliers\r\n  async addSupplierToProduct(\r\n    productId: string, \r\n    supplierData: { name: string; contact_email?: string; phone?: string; notes?: string }, \r\n    price: number\r\n  ): Promise<ProductSupplier> {\r\n    // First, check if supplier exists or create new one\r\n    let supplierId: string;\r\n    \r\n    const { data: existingSupplier } = await supabase\r\n      .from('suppliers')\r\n      .select('id')\r\n      .eq('name', supplierData.name)\r\n      .single();\r\n\r\n    if (existingSupplier) {\r\n      supplierId = existingSupplier.id;\r\n    } else {\r\n      // Create new supplier\r\n      const { data: newSupplier, error: supplierError } = await supabase\r\n        .from('suppliers')\r\n        .insert([supplierData])\r\n        .select()\r\n        .single();\r\n\r\n      if (supplierError) {\r\n        console.error('Error creating supplier:', supplierError);\r\n        throw supplierError;\r\n      }\r\n\r\n      supplierId = newSupplier.id;\r\n    }\r\n\r\n    // Now create the product-supplier relationship\r\n    const { data, error } = await supabase\r\n      .from('product_suppliers')\r\n      .insert([{\r\n        product_id: productId,\r\n        supplier_id: supplierId,\r\n        current_price: price\r\n      }])\r\n      .select(`\r\n        *,\r\n        supplier:suppliers(*)\r\n      `)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error adding supplier to product:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  async updateSupplierPrice(productSupplierId: string, newPrice: number, note?: string): Promise<ProductSupplier> {\r\n    const { data, error } = await supabase\r\n      .from('product_suppliers')\r\n      .update({ current_price: newPrice })\r\n      .eq('id', productSupplierId)\r\n      .select(`\r\n        *,\r\n        supplier:suppliers(*)\r\n      `)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error updating supplier price:', error);\r\n      throw error;\r\n    }\r\n\r\n    // Add price history entry if note is provided\r\n    if (note) {\r\n      await supabase\r\n        .from('price_history')\r\n        .insert([{\r\n          product_supplier_id: productSupplierId,\r\n          price: newPrice,\r\n          note\r\n        }]);\r\n    }\r\n\r\n    return data;\r\n  }\r\n\r\n  async removeSupplierFromProduct(productSupplierId: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('product_suppliers')\r\n      .delete()\r\n      .eq('id', productSupplierId);\r\n\r\n    if (error) {\r\n      console.error('Error removing supplier from product:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async getProductsByCategory(category: string): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n      .from('products')\r\n      .select('*')\r\n      .eq('category', category)\r\n      .order('name');\r\n\r\n    if (error) {\r\n      console.error('Error fetching products by category:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data || [];\r\n  }\r\n\r\n  async searchProducts(searchTerm: string): Promise<Product[]> {\r\n    const { data, error } = await supabase\r\n      .from('products')\r\n      .select('*')\r\n      .or(`name.ilike.%${searchTerm}%,sku.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)\r\n      .order('name');\r\n\r\n    if (error) {\r\n      console.error('Error searching products:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data || [];\r\n  }\r\n\r\n  async getSupplierPriceHistory(productSupplierId: string): Promise<PriceHistory[]> {\r\n    const { data, error } = await supabase\r\n      .from('price_history')\r\n      .select('*')\r\n      .eq('product_supplier_id', productSupplierId)\r\n      .order('timestamp', { ascending: false });\r\n\r\n    if (error) {\r\n      console.error('Error fetching price history:', error);\r\n      throw error;\r\n    }\r\n\r\n    return (data || []) as any;\r\n  }\r\n\r\n  async addClientToProduct(\r\n    productId: string, \r\n    clientData: { name: string; contact_email?: string; phone?: string; notes?: string }, \r\n    quotedPrice: number,\r\n    marginPercentage?: number\r\n  ): Promise<any> {\r\n    // First, check if client exists or create new one\r\n    let clientId: string;\r\n    \r\n    const { data: existingClient } = await supabase\r\n      .from('clients')\r\n      .select('id')\r\n      .eq('name', clientData.name)\r\n      .single();\r\n\r\n    if (existingClient) {\r\n      clientId = existingClient.id;\r\n    } else {\r\n      // Create new client\r\n      const { data: newClient, error: clientError } = await supabase\r\n        .from('clients')\r\n        .insert([clientData])\r\n        .select()\r\n        .single();\r\n\r\n      if (clientError) {\r\n        console.error('Error creating client:', clientError);\r\n        throw clientError;\r\n      }\r\n\r\n      clientId = newClient.id;\r\n    }\r\n\r\n    // Now create the product-client relationship\r\n    const { data, error } = await supabase\r\n      .from('product_clients')\r\n      .insert([{\r\n        product_id: productId,\r\n        client_id: clientId,\r\n        quoted_price: quotedPrice,\r\n        margin_percentage: marginPercentage\r\n      }])\r\n      .select(`\r\n        *,\r\n        client:clients(*)\r\n      `)\r\n      .single();\r\n\r\n    if (error) {\r\n      console.error('Error adding client to product:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data;\r\n  }\r\n}\r\n\r\nexport const productService = new ProductService();\r\n","import { supabase } from '@/integrations/supabase/client';\r\nimport { Printer } from '@/types/database';\r\n\r\nexport const printerService = {\r\n  // Get all printers (only active ones)\r\n  async getPrinters(): Promise<Printer[]> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .select('*')\r\n      .eq('status', 'active')\r\n      .order('name');\r\n    if (error) throw error;\r\n    return data || [];\r\n  },\r\n\r\n  // Get only assigned printers (printers that have assignments to clients)\r\n  async getAssignedPrinters(): Promise<any[]> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .select(`\r\n        *,\r\n        printer_assignments!inner(\r\n          id,\r\n          client_id,\r\n          status,\r\n          serial_number,\r\n          department_location:departments_location(\r\n            name,\r\n            department:departments (\r\n                name\r\n            )\r\n          ),\r\n          clients (\r\n            id,\r\n            name\r\n          )\r\n        )\r\n      `)\r\n      .eq('status', 'active')\r\n      .eq('printer_assignments.status', 'active')\r\n      .order('name');\r\n    \r\n    if (error) {\r\n      console.error('Error fetching assigned printers:', error);\r\n      throw error;\r\n    }\r\n    \r\n    return data || [];\r\n  },\r\n\r\n  // Search printers by name (only active ones)\r\n  async searchPrinters(searchTerm: string): Promise<Printer[]> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .select('*')\r\n      .eq('status', 'active')\r\n      .ilike('name', `%${searchTerm}%`)\r\n      .order('name');\r\n    if (error) throw error;\r\n    return data || [];\r\n  },\r\n\r\n  // Search only assigned printers by name\r\n  async searchAssignedPrinters(searchTerm: string): Promise<any[]> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .select(`\r\n        *,\r\n        printer_assignments!inner(\r\n          id,\r\n          client_id,\r\n          status,\r\n          serial_number,\r\n          clients(id, name)\r\n        )\r\n      `)\r\n      .eq('status', 'active')\r\n      .eq('printer_assignments.status', 'active')\r\n      .ilike('name', `%${searchTerm}%`)\r\n      .order('name');\r\n    \r\n    if (error) {\r\n      console.error('Error searching assigned printers:', error);\r\n      throw error;\r\n    }\r\n    \r\n    return data || [];\r\n  },\r\n\r\n  async createPrinter(printerData: Omit<Printer, 'id' | 'created_at' | 'updated_at'>): Promise<Printer> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .insert(printerData)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      console.error('Error creating printer:', error);\r\n      throw error;\r\n    }\r\n    \r\n    return data;\r\n  },\r\n\r\n  async updatePrinter(printerId: string, printerData: Partial<Omit<Printer, 'id' | 'created_at' | 'updated_at'>>): Promise<Printer> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .update(printerData)\r\n      .eq('id', printerId)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      console.error('Error updating printer:', error);\r\n      throw error;\r\n    }\r\n    \r\n    return data;\r\n  },\r\n\r\n  async findOrCreatePrinter(name: string): Promise<Printer> {\r\n    // First, try to find existing active printer\r\n    const { data: existingPrinter } = await supabase\r\n      .from('printers')\r\n      .select('*')\r\n      .eq('name', name.trim())\r\n      .eq('status', 'active')\r\n      .single();\r\n    \r\n    if (existingPrinter) {\r\n      return existingPrinter;\r\n    }\r\n    \r\n    // If not found, create new printer\r\n    return this.createPrinter({ name: name.trim() });\r\n  },\r\n\r\n  async addPrintersToProduct(productId: string, printerNames: string[]): Promise<void> {\r\n    // Remove existing printer associations\r\n    await supabase\r\n      .from('product_printers')\r\n      .delete()\r\n      .eq('product_id', productId);\r\n\r\n    if (printerNames.length === 0) return;\r\n\r\n    // Find or create printers and get their IDs\r\n    const printerIds: string[] = [];\r\n    for (const name of printerNames) {\r\n      const printer = await this.findOrCreatePrinter(name);\r\n      printerIds.push(printer.id);\r\n    }\r\n\r\n    // Create product-printer associations\r\n    const productPrinters = printerIds.map(printerId => ({\r\n      product_id: productId,\r\n      printer_id: printerId\r\n    }));\r\n\r\n    const { error } = await supabase\r\n      .from('product_printers')\r\n      .insert(productPrinters);\r\n\r\n    if (error) {\r\n      console.error('Error adding printers to product:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async updatePrinterProducts(printerId: string, productIds: string[]): Promise<void> {\r\n    // Remove existing product associations for this printer\r\n    await supabase\r\n      .from('product_printers')\r\n      .delete()\r\n      .eq('printer_id', printerId);\r\n\r\n    if (productIds.length === 0) return;\r\n\r\n    // Create new printer-product associations\r\n    const printerProducts = productIds.map(productId => ({\r\n      printer_id: printerId,\r\n      product_id: productId\r\n    }));\r\n\r\n    const { error } = await supabase\r\n      .from('product_printers')\r\n      .insert(printerProducts);\r\n\r\n    if (error) {\r\n      console.error('Error updating printer products:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async getProductPrinters(productId: string): Promise<Printer[]> {\r\n    const { data, error } = await supabase\r\n      .from('product_printers')\r\n      .select(`\r\n        printer:printers(*)\r\n      `)\r\n      .eq('product_id', productId);\r\n\r\n    if (error) {\r\n      console.error('Error fetching product printers:', error);\r\n      throw error;\r\n    }\r\n\r\n    return data?.map(pp => pp.printer).filter(Boolean) || [];\r\n  },\r\n\r\n  async deletePrinter(printerId: string, deletedBy?: string, reason?: string): Promise<void> {\r\n    try {\r\n      // Soft delete: only update status to 'deleted'\r\n      const { error: updateError } = await supabase\r\n        .from('printers')\r\n        .update({ \r\n          status: 'deleted',\r\n          is_available: false,\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', printerId);\r\n      \r\n      if (updateError) {\r\n        console.error('Error updating printer status:', updateError);\r\n        throw updateError;\r\n      }\r\n      \r\n      console.log(`Printer ${printerId} soft deleted successfully`);\r\n    } catch (error) {\r\n      console.error('Error in soft delete printer:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Soft delete printer: set is_available to false\r\n  async softDeletePrinter(printerId: string, deletedBy?: string, reason?: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('printers')\r\n      .update({ is_available: false })\r\n      .eq('id', printerId);\r\n    if (error) {\r\n      console.error('Error soft deleting printer:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get all available printers (is_available = true and active status)\r\n  async getAvailablePrinters(): Promise<Printer[]> {\r\n    const { data, error } = await supabase\r\n      .from('printers')\r\n      .select('*')\r\n      .eq('is_available', true)\r\n      .eq('status', 'active')\r\n      .order('name');\r\n    if (error) {\r\n      console.error('Error fetching available printers:', error);\r\n      throw error;\r\n    }\r\n    return data || [];\r\n  },\r\n\r\n  // Merge multiple printers into a primary printer\r\n  async mergePrinters(primaryId: string, mergeIds: string[]): Promise<void> {\r\n    if (mergeIds.length === 0) return;\r\n    // 1. Fetch all printers\r\n    const { data: allPrinters, error: fetchError } = await supabase\r\n      .from('printers')\r\n      .select('*')\r\n      .in('id', [primaryId, ...mergeIds]);\r\n    if (fetchError) throw fetchError;\r\n    const primary = allPrinters.find((p: any) => p.id === primaryId);\r\n    const toMerge = allPrinters.filter((p: any) => mergeIds.includes(p.id));\r\n    // 2. Collect aliases\r\n    const aliasSet = new Set<string>();\r\n    for (const p of toMerge) {\r\n      if (p.name) aliasSet.add(p.name);\r\n      if (p.model) aliasSet.add(p.model);\r\n      if (p.aliases) p.aliases.split(',').forEach((a: string) => aliasSet.add(a.trim()));\r\n    }\r\n    if (primary.aliases) primary.aliases.split(',').forEach((a: string) => aliasSet.add(a.trim()));\r\n    // Remove primary's own name/model from aliases\r\n    aliasSet.delete(primary.name);\r\n    if (primary.model) aliasSet.delete(primary.model);\r\n    // 3. Update primary printer's aliases\r\n    await supabase\r\n      .from('printers')\r\n      .update({ aliases: Array.from(aliasSet).join(', ') })\r\n      .eq('id', primaryId);\r\n    // 4. Update references in assignments/products/etc.\r\n    // Printer assignments\r\n    await supabase\r\n      .from('printer_assignments')\r\n      .update({ printer_id: primaryId })\r\n      .in('printer_id', mergeIds);\r\n    // Product printers\r\n    await supabase\r\n      .from('product_printers')\r\n      .update({ printer_id: primaryId })\r\n      .in('printer_id', mergeIds);\r\n    // 5. Delete merged printers\r\n    await supabase\r\n      .from('printers')\r\n      .delete()\r\n      .in('id', mergeIds);\r\n  },\r\n\r\n  // Get products associated with a printer by printer name\r\n  async getProductsByPrinterName(printerName: string): Promise<any[]> {\r\n    try {\r\n      // First, find the printer by name (including aliases)\r\n      const { data: printers, error: printerError } = await supabase\r\n        .from('printers')\r\n        .select('id')\r\n        .or(`name.ilike.%${printerName}%,aliases.ilike.%${printerName}%`);\r\n\r\n      if (printerError) {\r\n        console.error('Error finding printer:', printerError);\r\n        throw printerError;\r\n      }\r\n\r\n      if (!printers || printers.length === 0) {\r\n        return [];\r\n      }\r\n\r\n      // Get all printer IDs that match\r\n      const printerIds = printers.map(p => p.id);\r\n\r\n      // Find products linked to these printers\r\n      const { data: productPrinters, error: linkError } = await supabase\r\n        .from('product_printers')\r\n        .select(`\r\n          product:products(\r\n            id,\r\n            name,\r\n            sku,\r\n            category,\r\n            description,\r\n            color,\r\n            alias,\r\n            created_at,\r\n            updated_at\r\n          )\r\n        `)\r\n        .in('printer_id', printerIds);\r\n\r\n      if (linkError) {\r\n        console.error('Error finding linked products:', linkError);\r\n        throw linkError;\r\n      }\r\n\r\n      // Extract products from the nested structure\r\n      const products = productPrinters\r\n        ?.map(pp => pp.product)\r\n        .filter(Boolean) || [];\r\n\r\n      return products;\r\n    } catch (error) {\r\n      console.error('Error getting products by printer name:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Get printers assigned to a department location\r\n  async getPrintersByDepartmentLocation(departmentLocationId: string): Promise<any[]> {\r\n    const { data, error } = await supabase\r\n      .from('printer_assignments')\r\n      .select(`*, printer:printers(*)`)\r\n      .eq('department_location_id', departmentLocationId)\r\n      .eq('status', 'active');\r\n    if (error) {\r\n      console.error('Error fetching printers for department location:', error);\r\n      throw error;\r\n    }\r\n    // Each row: { ...assignment, printer: { ...printer fields } }\r\n    return data || [];\r\n  },\r\n\r\n  // Get all printers assigned to a client, with assignment and location info\r\n  async getPrintersByClient(clientId: string): Promise<any[]> {\r\n    const { data, error } = await supabase\r\n      .from('printer_assignments')\r\n      .select(`*, printer:printers(*), location:departments_location(*)`)\r\n      .eq('client_id', clientId)\r\n      .eq('status', 'active');\r\n    if (error) {\r\n      console.error('Error fetching printers for client:', error);\r\n      throw error;\r\n    }\r\n    // Each row: { ...assignment, printer: { ...printer fields }, location: { ...location fields } }\r\n    return data || [];\r\n  },\r\n\r\n  // Get all products linked to a client, with product details and printers that use each product\r\n  async getProductsByClient(clientId: string): Promise<any[]> {\r\n    const { data, error } = await supabase\r\n      .from('product_clients')\r\n      .select(`*, product:products(*, product_printers(printer:printers(*)))`)\r\n      .eq('client_id', clientId);\r\n    if (error) {\r\n      console.error('Error fetching products for client:', error);\r\n      throw error;\r\n    }\r\n    // Each row: { ...product_client, product: { ...product fields, product_printers: [{ printer: {...} }] } }\r\n    return data || [];\r\n  },\r\n\r\n  // Unassign a printer by assignment ID - Phase 1: Basic client unassignment\r\n  async unassignPrinter(assignmentId: string): Promise<boolean> {\r\n    try {\r\n      // For complete unassignment from client, set all assignment fields to null and status to 'available'\r\n      const { error: updateError } = await supabase\r\n        .from('printer_assignments')\r\n        .update({ \r\n          status: 'available',\r\n          client_id: null,\r\n          department_location_id: null,\r\n          department: null,\r\n          location: null,\r\n          is_unassigned: true,\r\n          reason_for_change: 'Unassigned from client - made available',\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', assignmentId);\r\n\r\n      if (updateError) {\r\n        console.error('Error updating assignment status:', updateError);\r\n        throw new Error(updateError.message);\r\n      }\r\n\r\n      console.log('Printer successfully unassigned and made available');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error in unassignPrinter:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  // Phase 2: Multi-level unassignment methods\r\n  async unassignFromLocation(assignmentId: string): Promise<boolean> {\r\n    try {\r\n      // Fetch the assignment to get the department name from the joined departments_location\r\n      const { data: assignment, error: fetchError } = await supabase\r\n        .from('printer_assignments')\r\n        .select('departments_location(department_id), id')\r\n        .eq('id', assignmentId)\r\n        .single();\r\n\r\n      if (fetchError) throw fetchError;\r\n\r\n      let departmentName: string | null = null;\r\n\r\n      if (assignment?.departments_location?.department_id) {\r\n        // Fetch the department name using the department_id\r\n        const { data: department, error: deptError } = await supabase\r\n          .from('departments')\r\n          .select('name')\r\n          .eq('id', assignment.departments_location.department_id)\r\n          .single();\r\n        if (deptError) throw deptError;\r\n        departmentName = department?.name || null;\r\n      }\r\n\r\n      // Update the assignment: clear location, preserve department\r\n      const { error: updateError } = await supabase\r\n        .from('printer_assignments')\r\n        .update({ \r\n          department_location_id: null,\r\n          location: null,\r\n          department: departmentName, // <-- preserve department for fallback\r\n          reason_for_change: 'Unassigned from location - remains with department',\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', assignmentId);\r\n\r\n      if (updateError) {\r\n        console.error('Error unassigning from location:', updateError);\r\n        throw new Error(updateError.message);\r\n      }\r\n\r\n      console.log('Printer successfully unassigned from location');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error in unassignFromLocation:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async unassignFromDepartment(assignmentId: string): Promise<boolean> {\r\n    try {\r\n      // Remove department and location assignment but keep client\r\n      const { error: updateError } = await supabase\r\n        .from('printer_assignments')\r\n        .update({ \r\n          department_location_id: null,\r\n          department: null,\r\n          location: null,\r\n          reason_for_change: 'Unassigned from department - remains with client',\r\n          updated_at: new Date().toISOString()\r\n        })\r\n        .eq('id', assignmentId);\r\n\r\n      if (updateError) {\r\n        console.error('Error unassigning from department:', updateError);\r\n        throw new Error(updateError.message);\r\n      }\r\n\r\n      console.log('Printer successfully unassigned from department');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Error in unassignFromDepartment:', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  async unassignFromClient(assignmentId: string): Promise<boolean> {\r\n    // For complete client unassignment, use the updated unassignPrinter method\r\n    return this.unassignPrinter(assignmentId);\r\n  },\r\n\r\n  // Create a printer assignment (for inventory)\r\n  async createPrinterAssignment(assignmentData: any): Promise<any> {\r\n    const { data, error } = await supabase\r\n      .from('printer_assignments')\r\n      .insert(assignmentData)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) {\r\n      console.error('Error creating printer assignment:', error);\r\n      throw error;\r\n    }\r\n    \r\n    return data;\r\n  },\r\n\r\n  // Get unique series values\r\n  async getUniqueSeries(manufacturer?: string): Promise<string[]> {\r\n    try {\r\n      let query = supabase\r\n        .from('printers')\r\n        .select('series')\r\n        .not('series', 'is', null)\r\n        .neq('series', '');\r\n\r\n      // Filter by manufacturer if provided\r\n      if (manufacturer && manufacturer.trim() !== '') {\r\n        query = query.eq('manufacturer', manufacturer);\r\n      }\r\n\r\n      const { data, error } = await query;\r\n\r\n      if (error) throw error;\r\n\r\n      // Extract unique series values\r\n      const uniqueSeries = [...new Set(data.map(item => item.series).filter(series => series && series.trim() !== ''))];\r\n      \r\n      // Sort alphabetically\r\n      return uniqueSeries.sort();\r\n    } catch (error) {\r\n      console.error('Error fetching unique series:', error);\r\n      throw error;\r\n    }\r\n  },\r\n};\r\n","\r\nimport { useState, useEffect } from 'react';\r\nimport { supabase } from '@/integrations/supabase/client';\r\nimport { Client } from '@/types/database';\r\n\r\nexport type { Client };\r\nimport { useToast } from '@/hooks/use-toast';\r\n\r\nexport const useClients = () => {\r\n  const [clients, setClients] = useState<Client[]>([]);\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { toast } = useToast();\r\n\r\n  const fetchClients = async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    try {\r\n      const { data, error } = await supabase\r\n        .from('clients')\r\n        .select('*')\r\n        .order('name');\r\n      if (!error && data) {\r\n        setClients(data);\r\n      } else {\r\n        setError('Failed to fetch clients');\r\n        toast({\r\n          title: 'Error',\r\n          description: 'Failed to fetch clients',\r\n          variant: 'destructive'\r\n        });\r\n      }\r\n    } catch (err) {\r\n      setError(err instanceof Error ? err.message : 'Failed to fetch clients');\r\n      toast({\r\n        title: 'Error',\r\n        description: 'Failed to fetch clients',\r\n        variant: 'destructive'\r\n      });\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  // Placeholder functions for missing functionality\r\n  const createClient = async () => {\r\n    toast({\r\n      title: 'Not Implemented',\r\n      description: 'Client creation will be implemented in a future update',\r\n      variant: 'default'\r\n    });\r\n  };\r\n\r\n  const updateClient = async () => {\r\n    toast({\r\n      title: 'Not Implemented', \r\n      description: 'Client updates will be implemented in a future update',\r\n      variant: 'default'\r\n    });\r\n  };\r\n\r\n  const archiveClient = async () => {\r\n    toast({\r\n      title: 'Not Implemented',\r\n      description: 'Client archiving will be implemented in a future update', \r\n      variant: 'default'\r\n    });\r\n  };\r\n\r\n  const restoreClient = async () => {\r\n    toast({\r\n      title: 'Not Implemented',\r\n      description: 'Client restoration will be implemented in a future update',\r\n      variant: 'default'\r\n    });\r\n  };\r\n\r\n  useEffect(() => {\r\n    fetchClients();\r\n  }, []);\r\n\r\n  return {\r\n    clients,\r\n    loading,\r\n    error,\r\n    refetch: fetchClients,\r\n    loadClients: fetchClients, // Alias for compatibility\r\n    categories: [], // Empty array for now\r\n    createClient,\r\n    updateClient,\r\n    archiveClient,\r\n    restoreClient\r\n  };\r\n};\r\n","import { supabase } from '@/integrations/supabase/client';\r\nimport { Client, ProductClient, ClientPriceHistory } from '@/types/database';\r\n\r\nexport const clientService = {\r\n  // Get all clients\r\n  async getClients(): Promise<Client[]> {\r\n    const { data, error } = await supabase\r\n      .from('clients')\r\n      .select(`\r\n        *,\r\n        printers: printer_assignments (\r\n          *,\r\n          printer:printers (\r\n            *,\r\n            product_printers(product_id)\r\n          )\r\n        )\r\n      `)\r\n      .order('name');\r\n    \r\n    if (error) throw error;\r\n    // The data structure now includes product_ids but not the full product object\r\n    // to keep the query fast and reliable. The full product object will be looked up on the client-side.\r\n    return data || [];\r\n  },\r\n\r\n  // Find client by email address\r\n  async findClientByEmail(email: string): Promise<Client | null> {\r\n    if (!email) return null;\r\n    \r\n    const { data, error } = await supabase\r\n      .from('clients')\r\n      .select('*')\r\n      .eq('contact_email', email.toLowerCase().trim())\r\n      .single();\r\n    \r\n    if (error) {\r\n      // If no client found, error.code will be 'PGRST116'\r\n      if (error.code === 'PGRST116') {\r\n        return null;\r\n      }\r\n      throw error;\r\n    }\r\n    \r\n    return data;\r\n  },\r\n\r\n  // Get client by ID\r\n  async getClientById(clientId: string): Promise<Client | null> {\r\n    if (!clientId) return null;\r\n    \r\n    const { data, error } = await supabase\r\n      .from('clients')\r\n      .select('*')\r\n      .eq('id', clientId)\r\n      .single();\r\n    \r\n    if (error) {\r\n      // If no client found, error.code will be 'PGRST116'\r\n      if (error.code === 'PGRST116') {\r\n        return null;\r\n      }\r\n      throw error;\r\n    }\r\n    \r\n    return data;\r\n  },\r\n\r\n  // Create a new client\r\n  async createClient(clientData: Omit<Client, 'id' | 'created_at' | 'updated_at'>): Promise<Client> {\r\n    const { data, error } = await supabase\r\n      .from('clients')\r\n      .insert(clientData)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  // Update a client\r\n  async updateClient(clientId: string, clientData: Partial<Client>): Promise<Client> {\r\n    const { data, error } = await supabase\r\n      .from('clients')\r\n      .update(clientData)\r\n      .eq('id', clientId)\r\n      .select()\r\n      .single();\r\n    \r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  // Delete a client\r\n  async deleteClient(clientId: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('clients')\r\n      .delete()\r\n      .eq('id', clientId);\r\n    \r\n    if (error) throw error;\r\n  },\r\n\r\n  // Add client to product with quoted price\r\n  async addClientToProduct(\r\n    productId: string,\r\n    clientData: Omit<Client, 'id' | 'created_at' | 'updated_at'>,\r\n    quotedPrice: number,\r\n    marginPercentage?: number\r\n  ): Promise<ProductClient> {\r\n    // First, check if client already exists\r\n    let client: Client;\r\n    const { data: existingClients } = await supabase\r\n      .from('clients')\r\n      .select('*')\r\n      .eq('name', clientData.name);\r\n\r\n    if (existingClients && existingClients.length > 0) {\r\n      client = existingClients[0];\r\n    } else {\r\n      // Create new client\r\n      client = await this.createClient(clientData);\r\n    }\r\n\r\n    // Create product-client relationship\r\n    const { data, error } = await supabase\r\n      .from('product_clients')\r\n      .insert({\r\n        product_id: productId,\r\n        client_id: client.id,\r\n        quoted_price: quotedPrice,\r\n        margin_percentage: marginPercentage || 0,\r\n      })\r\n      .select('*, client:clients(*)')\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  // Update client quote price\r\n  async updateClientQuote(\r\n    productClientId: string,\r\n    quotedPrice: number,\r\n    marginPercentage?: number,\r\n    note?: string\r\n  ): Promise<ProductClient> {\r\n    const { data, error } = await supabase\r\n      .from('product_clients')\r\n      .update({\r\n        quoted_price: quotedPrice,\r\n        margin_percentage: marginPercentage,\r\n      })\r\n      .eq('id', productClientId)\r\n      .select('*, client:clients(*)')\r\n      .single();\r\n\r\n    if (error) throw error;\r\n    return data;\r\n  },\r\n\r\n  // Remove client from product\r\n  async removeClientFromProduct(productClientId: string): Promise<void> {\r\n    const { error } = await supabase\r\n      .from('product_clients')\r\n      .delete()\r\n      .eq('id', productClientId);\r\n\r\n    if (error) throw error;\r\n  },\r\n\r\n  // Get clients for a specific product\r\n  async getProductClients(productId: string): Promise<(ProductClient & { client: Client; priceHistory: ClientPriceHistory[] })[]> {\r\n    const { data, error } = await supabase\r\n      .from('product_clients')\r\n      .select(`\r\n        *,\r\n        client:clients(*),\r\n        priceHistory:client_price_history(*)\r\n      `)\r\n      .eq('product_id', productId)\r\n      .order('created_at');\r\n\r\n    if (error) throw error;\r\n    return (data || []) as any;\r\n  },\r\n\r\n  // Get client price history\r\n  async getClientPriceHistory(productClientId: string): Promise<ClientPriceHistory[]> {\r\n    const { data, error } = await supabase\r\n      .from('client_price_history')\r\n      .select('*')\r\n      .eq('product_client_id', productClientId)\r\n      .order('timestamp', { ascending: false });\r\n\r\n    if (error) throw error;\r\n    return (data || []) as any;\r\n  },\r\n\r\n  // Merge multiple clients into one\r\n  async mergeClients(\r\n    clientIds: string[],\r\n    mergedClientData: {\r\n      name: string;\r\n      contact_email?: string;\r\n      phone?: string;\r\n      notes?: string;\r\n    }\r\n  ): Promise<Client> {\r\n    console.log('Starting client merge process...', { clientIds, mergedClientData });\r\n\r\n    if (clientIds.length < 2) {\r\n      throw new Error('At least 2 clients are required for merging');\r\n    }\r\n\r\n    // Create the new merged client\r\n    const mergedClient = await this.createClient(mergedClientData);\r\n    console.log('Created merged client:', mergedClient);\r\n\r\n    // Get all product-client relationships for the clients being merged\r\n    const { data: productClients, error: productClientsError } = await supabase\r\n      .from('product_clients')\r\n      .select('*')\r\n      .in('client_id', clientIds);\r\n\r\n    if (productClientsError) {\r\n      console.error('Error fetching product clients:', productClientsError);\r\n      throw productClientsError;\r\n    }\r\n\r\n    console.log('Found product clients to merge:', productClients);\r\n\r\n    // Group by product_id to handle duplicates\r\n    const productClientMap = new Map<string, any[]>();\r\n    productClients?.forEach(pc => {\r\n      if (!productClientMap.has(pc.product_id)) {\r\n        productClientMap.set(pc.product_id, []);\r\n      }\r\n      productClientMap.get(pc.product_id)!.push(pc);\r\n    });\r\n\r\n    // For each product, merge client relationships\r\n    for (const [productId, clientRelations] of productClientMap) {\r\n      console.log(`Processing product ${productId} with ${clientRelations.length} client relations`);\r\n\r\n      if (clientRelations.length === 1) {\r\n        // Only one relation for this product, just update the client_id\r\n        const relation = clientRelations[0];\r\n        const { error: updateError } = await supabase\r\n          .from('product_clients')\r\n          .update({ client_id: mergedClient.id })\r\n          .eq('id', relation.id);\r\n\r\n        if (updateError) {\r\n          console.error('Error updating product client relation:', updateError);\r\n          throw updateError;\r\n        }\r\n      } else {\r\n        // Multiple relations for same product, need to merge them\r\n        // Keep the one with the most recent updated_at (or highest price)\r\n        const primaryRelation = clientRelations.reduce((best, current) => {\r\n          if (current.quoted_price > best.quoted_price) return current;\r\n          if (current.quoted_price === best.quoted_price && \r\n              new Date(current.updated_at) > new Date(best.updated_at)) return current;\r\n          return best;\r\n        });\r\n\r\n        // Update the primary relation to use the merged client\r\n        const { error: updateError } = await supabase\r\n          .from('product_clients')\r\n          .update({ client_id: mergedClient.id })\r\n          .eq('id', primaryRelation.id);\r\n\r\n        if (updateError) {\r\n          console.error('Error updating primary relation:', updateError);\r\n          throw updateError;\r\n        }\r\n\r\n        // Delete the duplicate relations\r\n        const duplicateIds = clientRelations\r\n          .filter(r => r.id !== primaryRelation.id)\r\n          .map(r => r.id);\r\n\r\n        if (duplicateIds.length > 0) {\r\n          const { error: deleteError } = await supabase\r\n            .from('product_clients')\r\n            .delete()\r\n            .in('id', duplicateIds);\r\n\r\n          if (deleteError) {\r\n            console.error('Error deleting duplicate relations:', deleteError);\r\n            throw deleteError;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Delete the original clients\r\n    const { error: deleteError } = await supabase\r\n      .from('clients')\r\n      .delete()\r\n      .in('id', clientIds);\r\n\r\n    if (deleteError) {\r\n      console.error('Error deleting original clients:', deleteError);\r\n      throw deleteError;\r\n    }\r\n\r\n    console.log('Client merge completed successfully');\r\n    return mergedClient;\r\n  },\r\n\r\n  // Get all department locations for a client, combining department and location\r\n  async getDepartmentsByClient(clientId: string): Promise<{ id: string; name: string; location?: string }[]> {\r\n    const { data: departments, error: deptError } = await supabase\r\n      .from('departments')\r\n      .select(`id, name, locations:departments_location(id, name)`)\r\n      .eq('client_id', clientId)\r\n      .order('name');\r\n    if (deptError) throw deptError;\r\n    if (!departments) return [];\r\n    // Flatten to array of { id, name: 'Department - Location', location }\r\n    const result: { id: string; name: string; location?: string }[] = [];\r\n    for (const dept of departments) {\r\n      for (const loc of dept.locations || []) {\r\n        result.push({\r\n          id: loc.id,\r\n          name: `${dept.name} - ${loc.name}`,\r\n          location: loc.name\r\n        });\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n};\r\n"],"names":["ProductService","data","error","supabase","id","printerId","pp","productId","product","productError","suppliers","suppliersError","printers","printersError","clients","clientsError","productData","replacementProductId","transactions","fetchError","updateError","primaryProductId","otherProductIds","newAlias","primaryProduct","mergedData","otherId","otherProduct","transactionError","linkingTables","tableInfo","relatedItems","itemsToUpsert","item","product_id","rest","upsertError","deleteError","supplierData","price","supplierId","existingSupplier","newSupplier","supplierError","productSupplierId","newPrice","note","category","searchTerm","clientData","quotedPrice","marginPercentage","clientId","existingClient","newClient","clientError","productService","printerService","printerData","name","existingPrinter","printerNames","printerIds","printer","productPrinters","productIds","printerProducts","deletedBy","reason","primaryId","mergeIds","allPrinters","primary","p","toMerge","aliasSet","a","printerName","printerError","linkError","departmentLocationId","assignmentId","assignment","departmentName","_a","department","deptError","assignmentData","manufacturer","query","series","useClients","setClients","useState","loading","setLoading","setError","toast","useToast","fetchClients","err","createClient","updateClient","archiveClient","restoreClient","useEffect","clientService","email","client","existingClients","productClientId","clientIds","mergedClientData","mergedClient","productClients","productClientsError","productClientMap","pc","clientRelations","relation","primaryRelation","best","current","duplicateIds","r","departments","result","dept","loc"],"mappings":"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"}